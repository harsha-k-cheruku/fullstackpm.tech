# Web Development Concepts You Should Know

## HTTP: The Language of the Web

HTTP = HyperText Transfer Protocol = How browsers talk to servers

### Request (Browser → Server)

```
GET /blog/my-post HTTP/1.1
Host: fullstackpm.tech
User-Agent: Mozilla/5.0
Accept: text/html
```

**Breaking it down:**
- `GET` = What action (GET=fetch, POST=send, PUT=update, DELETE=remove)
- `/blog/my-post` = What resource
- `HTTP/1.1` = Protocol version
- Headers = Metadata about the request

### Response (Server → Browser)

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 5432

<!DOCTYPE html>
<html>...
</html>
```

**Breaking it down:**
- `200` = Status code (200=success, 404=not found, 500=error)
- `Content-Type` = What kind of data (HTML, JSON, CSS, etc.)
- Body = The actual content

### Status Codes You'll See

| Code | Meaning | Example |
|------|---------|---------|
| **200** | OK | Request succeeded |
| **301** | Moved Permanently | Redirect to new URL |
| **404** | Not Found | Page doesn't exist |
| **500** | Internal Server Error | Your app crashed |
| **503** | Service Unavailable | Server is down for maintenance |

---

## URLs: How the Web is Organized

```
https://fullstackpm.tech/blog/what-is-fullstack-pm?page=1#introduction
```

Breaking it down:

| Part | Name | What it means |
|------|------|---|
| `https://` | Protocol | Secure HTTP connection |
| `fullstackpm.tech` | Domain | Which server |
| `/blog/what-is-fullstack-pm` | Path | Which resource on that server |
| `?page=1` | Query string | Parameters/filters |
| `#introduction` | Fragment | Jump to section in page |

### Your Routes

Your Procfile is essentially defining these URLs:

```python
GET /                    → home.html
GET /about              → about.html
GET /contact            → contact.html
GET /resume             → resume.html
GET /projects           → gallery of all projects
GET /projects/{slug}    → individual project
GET /blog               → list of all blog posts
GET /blog/{slug}        → individual blog post
GET /blog/tag/{tag}     → posts with specific tag
GET /feed.xml           → RSS feed (XML format)
GET /sitemap.xml        → For Google crawlers
GET /robots.txt         → Instructions for crawlers
```

When someone visits `fullstackpm.tech/blog/why-im-building`, FastAPI sees the `/blog/{slug}` pattern and routes to your blog.py handler.

---

## Request → Response Flow

### Example: Visiting Your Home Page

```
1. User types fullstackpm.tech into browser
2. Browser sends: GET / HTTP/1.1

3. Request goes to Render servers

4. Uvicorn (web server) receives request
5. Passes to FastAPI app

6. FastAPI checks routes:
   @app.get("/")
   async def home(request: Request):
       return templates.TemplateResponse("home.html", ...)

7. Python code:
   - Loads home.html template
   - Gets config/year/other data
   - Jinja2 renders template with data
   - Returns HTML

8. Uvicorn converts to HTTP response:
   HTTP/1.1 200 OK
   Content-Type: text/html
   <html>...</html>

9. Response travels across internet back to user's browser

10. Browser receives HTML and displays it

11. Browser sees <link href="/static/css/custom.css">
12. Browser makes NEW request: GET /static/css/custom.css
13. Server responds with CSS file
14. Browser applies styles to HTML

15. Page appears on user's screen
```

---

## MVC Architecture (What Your App Uses)

MVC = Model-View-Controller

Your app is actually **not quite MVC**, but it's close. Here's the mapping:

| Component | Your Code | What It Does |
|-----------|-----------|------|
| **Model** | `code/app/services/` | Business logic, data handling |
| **View** | `code/app/templates/` | HTML templates (what user sees) |
| **Controller** | `code/app/routers/` | Routes requests, calls models, passes to views |

### Flow

```
Request → Router (Controller) → Service (Model) → Template (View) → Response
```

**Example:**

```python
# Router (Controller)
@app.get("/blog/{slug}")
async def blog_detail(slug: str):
    # Call Service (Model)
    post = content_service.get_post_by_slug(slug)

    # Pass to Template (View)
    return templates.TemplateResponse("blog/detail.html", {"post": post})
```

---

## Static vs. Dynamic Content

### Static Content

**What:** Files that never change (CSS, JavaScript, images)

```
/static/css/custom.css
/static/js/main.js
/static/images/logo.png
```

**How served:**
- Browser requests file
- Web server returns file as-is
- No code execution needed
- Very fast

**Your code:**
```python
app.mount("/static", StaticFiles(directory="static"))
```

### Dynamic Content

**What:** Content generated by code (HTML pages)

```
GET /blog/my-post → Code runs → HTML generated → Sent to browser
```

**Why dynamic?**
- Same template (blog/detail.html)
- Different data each time (post.title, post.content, etc.)
- Rendered with values filled in

**Your code:**
```python
post = content_service.get_post_by_slug(slug)  # Data lookup
return templates.TemplateResponse(              # Template + data
    "blog/detail.html",
    {"post": post}
)
```

---

## Caching: Why Your App is Fast

Caching = Storing stuff so you don't have to recalculate it

### Your App's Cache

**Startup (happens once when app starts):**
```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    content_service = ContentService(settings.content_dir)
    content_service.load()  # ← Load ALL markdown files into memory
    app.state.content_service = content_service
    yield
```

**What happens:**
1. App starts
2. Reads all files from `/code/content/blog/` and `/code/content/projects/`
3. Parses markdown → HTML (happens once)
4. Stores in memory (RAM)
5. Per request, just look up from cache (super fast)

**Without cache:**
- Every request would read files from disk
- Every request would convert markdown to HTML
- App would be slow

**With cache:**
- First request: Fast
- Second request: Same speed (just lookup)
- 100th request: Same speed (just lookup)

---

## Server-Side Rendering vs. Client-Side Rendering

### Server-Side (What You're Using)

```
Browser → Server → HTML fully rendered → Browser displays it
```

**Advantages:**
- SEO friendly (Google can read the HTML)
- Simpler to build
- Better performance on slow networks
- Works without JavaScript

**Disadvantages:**
- Every change requires page reload
- More work on server
- Not interactive (yet)

### Client-Side (React, Vue, Angular)

```
Browser → Server → Empty HTML + JavaScript → JavaScript runs in browser → Browser renders page
```

**Advantages:**
- Very interactive (no page reloads)
- Snappy user experience
- Can work offline

**Disadvantages:**
- More complex to build
- SEO harder
- Requires JavaScript enabled
- Slower initial load

---

## Asynchronous Programming (async/await)

Your code uses `async/await`:

```python
@app.get("/blog/{slug}")
async def blog_detail(request: Request, slug: str):
    content_service = request.app.state.content_service
    post = content_service.get_post_by_slug(slug)
    ...
```

### What Does Async Mean?

Async = "Don't wait for this to finish, do other things meanwhile"

### Why It Matters

```
Without async (blocking):
- Request 1 arrives
- Server processes it (2 seconds)
- Server waits for it to finish
- Request 2 arrives
- Server can now process it
- Result: Slow! Only 1 request at a time

With async (non-blocking):
- Request 1 arrives
- Server starts processing it
- Request 2 arrives immediately
- Server handles both simultaneously
- Result: Fast! Many requests at once
```

### Your App's Requests Are Fast Because:
1. No database calls (super fast lookups from cache)
2. Async handling (can process many at once)
3. Content cached in memory (no disk reads)

---

## Templates: How HTML Gets Dynamic Data

### Jinja2 Syntax

**Variable insertion:**
```html
<h1>{{ post.title }}</h1>
<p>By {{ post.author }}</p>
```

**Conditionals:**
```html
{% if post %}
    <article>{{ post.html_content }}</article>
{% else %}
    <p>Post not found</p>
{% endif %}
```

**Loops:**
```html
{% for tag in post.tags %}
    <span>{{ tag }}</span>
{% endfor %}
```

**Inheritance:**
```html
{% extends "base.html" %}

{% block content %}
    <p>This goes inside base.html's {% block content %}</p>
{% endblock %}
```

### Why Templates?

Without templates (bad):
```python
html = "<h1>" + post.title + "</h1>"
html += "<p>By " + post.author + "</p>"
html += "<div>" + post.content + "</div>"
return html
```

With templates (good):
```html
<h1>{{ post.title }}</h1>
<p>By {{ post.author }}</p>
<div>{{ post.content }}</div>
```

Templates are **cleaner, safer, easier to maintain**.

---

## HTMX: Making Your Site Interactive Without JavaScript

HTMX = Let you access modern browser features directly from HTML

### Traditional Approach

User clicks button → JavaScript event → API call → JavaScript parses JSON → Update DOM

### HTMX Approach

User clicks button → Browser makes request → Server returns HTML → Browser replaces element

**Example:**

```html
<!-- Without HTMX (requires JavaScript) -->
<button onclick="loadMorePosts()">Load More</button>
<script>
function loadMorePosts() {
  fetch('/api/blog/posts?page=2')
    .then(r => r.text())
    .then(html => document.getElementById('posts').innerHTML = html)
}
</script>

<!-- With HTMX (just HTML) -->
<button hx-get="/api/blog/posts?page=2" hx-target="#posts">
  Load More
</button>
```

**Why HTMX?**
- Keeps everything on server (safer)
- No JavaScript to maintain
- Progressive enhancement (works without JS)
- HTML-centric (what you know)

---

## Dark Mode: CSS Variables and the DOM

Your site supports dark mode. Here's how:

### HTML Side

```html
<html class="">  <!-- light mode (no class) -->
<!-- OR -->
<html class="dark">  <!-- dark mode (has class) -->
```

### CSS Side

```css
:root {
  --color-bg-primary: #FFFFFF;  /* light mode */
  --color-text-primary: #000000;
}

.dark {
  --color-bg-primary: #0F172A;  /* dark mode */
  --color-text-primary: #FFFFFF;
}

body {
  background-color: var(--color-bg-primary);  /* Uses appropriate value */
  color: var(--color-text-primary);
}
```

### JavaScript Side

```javascript
// On page load
var theme = localStorage.getItem('theme');
if (theme === 'dark') {
    document.documentElement.classList.add('dark');
}

// When user clicks dark mode toggle
function toggleDarkMode() {
    document.documentElement.classList.toggle('dark');
    localStorage.setItem('theme', 'dark');  // Remember preference
}
```

---

## SEO: Making Your Site Findable

SEO = Search Engine Optimization = Getting Google to rank you

### What You Have

1. **Meta tags** (in base.html):
```html
<meta name="description" content="...">
<meta property="og:title" content="...">
```

2. **Sitemap** (/sitemap.xml):
```xml
<url>
  <loc>fullstackpm.tech/blog/my-post</loc>
  <changefreq>monthly</changefreq>
  <priority>0.7</priority>
</url>
```

3. **RSS feed** (/feed.xml):
```xml
<item>
  <title>My Post</title>
  <link>fullstackpm.tech/blog/my-post</link>
</item>
```

4. **robots.txt** (/robots.txt):
```
User-agent: *
Allow: /
Sitemap: fullstackpm.tech/sitemap.xml
```

### Why This Matters

- **Meta tags** → Show up in search results
- **Sitemap** → Tell Google which pages exist
- **RSS** → Let people subscribe to updates
- **robots.txt** → Tell Google what to crawl

---

## REST APIs (For Future)

Your app is currently server-side rendered HTML. But you also have REST endpoints:

```
GET /api/blog/posts?page=2      → Returns HTML partial
GET /api/projects/filter?status=live → Returns HTML partial
```

These are REST-ish (not pure REST, but following similar principles):

```
GET    /resource      → Get data
POST   /resource      → Create
PUT    /resource/:id  → Update
DELETE /resource/:id  → Delete
```

Future projects (PM Interview Coach) will use more of these.

---

## Performance: What Makes Web Apps Fast

### Key Metrics

| Metric | Target | What It Means |
|--------|--------|---|
| **TTFB** | <200ms | Time to first byte |
| **FCP** | <1.8s | Time until first paint |
| **LCP** | <2.5s | Time until page is interactive |
| **CLS** | <0.1 | Page doesn't jump around while loading |

### Your App's Performance

**Why it's fast:**
1. ✅ Content cached in RAM (not disk reads)
2. ✅ Markdown pre-rendered to HTML (not on every request)
3. ✅ Async handling (processes multiple requests)
4. ✅ Minimal static files (small CSS, no heavy JS)
5. ✅ CDN-hosted CSS (Tailwind from CDN, not your server)

**Your likely TTFB:** <100ms (very fast!)

---

## Security: Things to Remember

### ✅ You're Doing Right

- No user authentication (no password database to hack)
- No forms that process data
- Using HTTPS (Render provides SSL automatically)
- No secrets in code (environment variables only)

### ⚠️ When You Add Features

- **User accounts** → Hash passwords, use sessions
- **Forms** → Validate on both client and server
- **Databases** → SQL injection attacks
- **API keys** → Never commit to Git

---

## The Full Picture

```
Internet
    ↓
Render (cloud server)
    ↓
Uvicorn (web server process)
    ↓
FastAPI (web framework)
    ↓
Routers (decide which code to run)
    ↓
Services (business logic)
    ↓
Templates (HTML generation)
    ↓
Response sent back to browser
    ↓
Browser renders HTML/CSS
    ↓
User sees your website
```

At each layer, there are opportunities for things to go wrong—but also for things to work beautifully.

---

**Key Takeaway:** Web development is just **HTTP + a web framework + a template engine + a database (optional)**. Everything else is details. Once you understand these pieces, you can build anything.
